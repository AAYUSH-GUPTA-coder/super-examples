{
    "function": "constructor",
    "contract": "TradeableCashflow",
    "sourceName": "contracts/RedirectAll.sol",
    "sourceContent": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {\n    ISuperfluid,\n    ISuperToken,\n    ISuperApp,\n    ISuperAgreement,\n    SuperAppDefinitions\n} from \"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\";\n\nimport {CFAv1Library} from \"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\";\n\nimport {IConstantFlowAgreementV1} from \"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\";\n\nimport {SuperAppBase} from \"@superfluid-finance/ethereum-contracts/contracts/apps/SuperAppBase.sol\";\n\n/// @dev Constant Flow Agreement registration key, used to get the address from the host.\nbytes32 constant CFA_ID = keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\");\n\n/// @dev Thrown when the receiver is the zero adress.\nerror InvalidReceiver();\n\n/// @dev Thrown when receiver is also a super app.\nerror ReceiverIsSuperApp();\n\n/// @dev Thrown when the callback caller is not the host.\nerror Unauthorized();\n\n/// @dev Thrown when the token being streamed to this contract is invalid\nerror InvalidToken();\n\n/// @dev Thrown when the agreement is other than the Constant Flow Agreement V1\nerror InvalidAgreement();\n\n/// @title Stream Redirection Contract\n/// @notice This contract is a registered super app, meaning it receives\ncontract RedirectAll is SuperAppBase {\n\n    // CFA library setup\n    using CFAv1Library for CFAv1Library.InitData;\n    CFAv1Library.InitData public cfaV1Lib;\n\n    /// @dev Super token that may be streamed to this contract\n    ISuperToken internal immutable _acceptedToken;\n\n    /// @notice This is the current receiver that all streams will be redirected to.\n    address public _receiver;\n\n    constructor(ISuperfluid host, ISuperToken acceptedToken, address receiver) {\n        assert(address(host) != address(0));\n        assert(address(acceptedToken) != address(0));\n        assert(_receiver != address(0));\n\n        _acceptedToken = acceptedToken;\n        _receiver = receiver;\n\n        cfaV1Lib = CFAv1Library.InitData({\n            host: host,\n            cfa: IConstantFlowAgreementV1(address(host.getAgreementClass(CFA_ID)))\n        });\n\n        // Registers Super App, indicating it is the final level (it cannot stream to other super\n        // apps), and that the `before*` callbacks should not be called on this contract, only the\n        // `after*` callbacks.\n        host.registerApp(\n            SuperAppDefinitions.APP_LEVEL_FINAL |\n                SuperAppDefinitions.BEFORE_AGREEMENT_CREATED_NOOP |\n                SuperAppDefinitions.BEFORE_AGREEMENT_UPDATED_NOOP |\n                SuperAppDefinitions.BEFORE_AGREEMENT_TERMINATED_NOOP\n        );\n    }\n\n    // *************************************************************************\n    // EVENTS\n    // *************************************************************************\n\n    /// @dev Logged when the receiver changes\n    /// @param receiver The new receiver address.\n    event ReceiverChanged(address indexed receiver);\n\n    // *************************************************************************\n    // MODIFIERS\n    // *************************************************************************\n\n    modifier onlyHost() {\n        if (msg.sender != address(cfaV1Lib.host)) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyExpected(ISuperToken superToken, address agreementClass) {\n        if (superToken != _acceptedToken) revert InvalidToken();\n        if (agreementClass != address(cfaV1Lib.cfa)) revert InvalidAgreement();\n        _;\n    }\n\n    // *************************************************************************\n    // RECEIVER DATA\n    // *************************************************************************\n\n    /// @notice Returns current receiver's address, start time, and flow rate.\n    /// @return startTime Start time of the current flow.\n    /// @return receiver Receiving address.\n    /// @return flowRate Flow rate from this contract to the receiver.\n    function currentReceiver()\n        external\n        view\n        returns (uint256 startTime, address receiver, int96 flowRate)\n    {\n        if (receiver != address(0)) {\n            (startTime, flowRate, ,) = cfaV1Lib.cfa.getFlow(\n                _acceptedToken,\n                address(this),\n                _receiver\n            );\n\n            receiver = _receiver;\n        }\n    }\n\n    // *************************************************************************\n    // SUPER APP CALLBACKS\n    // *************************************************************************\n\n    function afterAgreementCreated(\n        ISuperToken _superToken,\n        address _agreementClass,\n        bytes32, //_agreementId\n        bytes calldata, //_agreementData\n        bytes calldata, //_cbdata\n        bytes calldata _ctx\n    )\n        external\n        override\n        onlyExpected(_superToken, _agreementClass)\n        onlyHost\n        returns (bytes memory newCtx)\n    {\n        return _updateOutflow(_ctx);\n    }\n\n    function afterAgreementUpdated(\n        ISuperToken _superToken,\n        address _agreementClass,\n        bytes32, // _agreementId,\n        bytes calldata, // _agreementData,\n        bytes calldata, // _cbdata,\n        bytes calldata _ctx\n    )\n        external\n        override\n        onlyExpected(_superToken, _agreementClass)\n        onlyHost\n        returns (bytes memory newCtx)\n    {\n        return _updateOutflow(_ctx);\n    }\n\n    function afterAgreementTerminated(\n        ISuperToken _superToken,\n        address _agreementClass,\n        bytes32, // _agreementId,\n        bytes calldata, // _agreementData\n        bytes calldata, // _cbdata,\n        bytes calldata _ctx\n    ) external override onlyHost returns (bytes memory newCtx) {\n\n        // According to the app basic law, we should never revert in a termination callback\n        if (_superToken != _acceptedToken || _agreementClass != address(cfaV1Lib.cfa)) {\n            return _ctx;\n        }\n\n        return _updateOutflow(_ctx);\n    }\n\n    // *************************************************************************\n    // INTERNAL LOGIC\n    // *************************************************************************\n\n    /// @dev Changes receiver and redirects all flows to the new one. Logs `ReceiverChanged`.\n    /// @param newReceiver The new receiver to redirect to.\n    function _changeReceiver(address newReceiver) internal {\n        if (newReceiver == address(0)) revert InvalidReceiver();\n\n        if (cfaV1Lib.host.isApp(ISuperApp(newReceiver))) revert ReceiverIsSuperApp();\n\n        if (newReceiver == _receiver) return;\n\n        (, int96 outFlowRate, ,) = cfaV1Lib.cfa.getFlow(_acceptedToken, address(this), _receiver);\n\n        if (outFlowRate > 0) {\n            cfaV1Lib.deleteFlow(address(this), _receiver, _acceptedToken);\n\n            cfaV1Lib.createFlow(\n                newReceiver,\n                _acceptedToken,\n                cfaV1Lib.cfa.getNetFlow(_acceptedToken, address(this))\n            );\n        }\n\n        _receiver = newReceiver;\n\n        emit ReceiverChanged(newReceiver);\n    }\n\n    /// @dev Updates the outflow. The flow is either created, updated, or deleted, depending on the\n    /// net flow rate.\n    /// @param ctx The context byte array from the Host's calldata.\n    /// @return newCtx The new context byte array to be returned to the Host.\n    function _updateOutflow(bytes calldata ctx) private returns (bytes memory newCtx) {\n        newCtx = ctx;\n\n        int96 netFlowRate = cfaV1Lib.cfa.getNetFlow(_acceptedToken, address(this));\n\n        (, int96 outFlowRate, , ) = cfaV1Lib.cfa.getFlow(_acceptedToken, address(this), _receiver);\n\n        int96 inFlowRate = netFlowRate + outFlowRate;\n\n        if (inFlowRate == 0) {\n            // The flow does exist and should be deleted.\n            newCtx = cfaV1Lib.deleteFlowWithCtx(ctx, address(this), _receiver, _acceptedToken);\n\n        } else if (outFlowRate != 0) {\n            // The flow does exist and needs to be updated.\n            newCtx = cfaV1Lib.updateFlowWithCtx(ctx, _receiver, _acceptedToken, inFlowRate);\n\n        } else {\n            // The flow does not exist but should be created.\n            newCtx = cfaV1Lib.createFlowWithCtx(ctx, _receiver, _acceptedToken, inFlowRate);\n        }\n    }\n}\n"
}
